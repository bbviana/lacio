{"version":3,"sources":["api/api.js","api/reducer.js","App/Significados.js","App/WordGraph.js","App/App.js","App/index.js","serviceWorker.js","index.js"],"names":["dominios","palavra","page","axios","get","relacionadas","dominio","significados","isNotInCollection","currentNodes","node","find","it","id","merge","priorityNodes","otherNodes","filter","receiveDominios","previousState","action","data","length","currentElements","elements","nodes","currentEdges","edges","currentClusters","clusters","palavraNode","label","context","type","newNodes","map","newEdges","source","target","push","newCluster","concat","newClusterAdded","newClusters","currentCluster","isOnCurrentCluster","indexOf","palavraBusca","currentNode","receiveRelacionadas","dominioNode","receiveSignificados","console","log","significado","definicoes","Significados","props","ref","React","createRef","this","current","addEventListener","e","stopPropagation","className","i","key","join","texto","score","Component","cytoscape","use","cise","WordGraph","graph","onClickNode","onClickEdge","cy","container","style","selector","ele","on","renderedPosition","formattedElements","toCytoscapeFormat","remove","add","layout","name","fit","nodeRepulsion","ready","$","run","nextProps","nextState","nextContext","draw","App","state","onChangeBusca","setState","value","onSearch","preventDefault","fetchDominios","nextPage","onClickPalavra","onClickDominio","fetchRelacionadas","edge","fetchSignificados","api","then","reducer","newState","clearSignificado","document","buscaValue","Header","onSubmit","placeholder","autoFocus","onChange","Subtitle","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","registration","unregister"],"mappings":"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","file":"static/js/main.cad3b019.chunk.js","sourcesContent":["import axios from 'axios';\n\nconst dominios = (palavra, page) => {\n    return axios.get(`/api/dominios/${palavra}/${page}`);\n};\n\nconst relacionadas = (dominio, palavra, page) => {\n    return axios.get(`/api/relacionadas/${dominio}/${palavra}/${page}`);\n};\n\nconst significados = (dominio, palavra) => {\n    return axios.get(`/api/significados/${dominio}/${palavra}`);\n};\n\nexport default {\n    dominios,\n    relacionadas,\n    significados\n}","const isNotInCollection = currentNodes => node => !currentNodes.find(it => it.id === node.id);\n\n/**\n * Retorna um array contendo os elementos de priorityNodes mais os elementos de otherNodes que não estejam no primeiro\n */\nconst merge = (priorityNodes, otherNodes) => {\n    return [\n        ...priorityNodes,\n        ...otherNodes.filter(isNotInCollection(priorityNodes))\n    ];\n};\n\nconst receiveDominios = (previousState, action) => {\n    const {palavra, page, data} = action;\n\n    if (data.length === 0) {\n        return previousState;\n    }\n\n    const currentElements = previousState.elements;\n\n    const currentNodes = currentElements.nodes;\n    const currentEdges = currentElements.edges;\n    const currentClusters = currentElements.clusters;\n\n    const palavraNode = {\n        id: `p_${palavra}`,\n        label: palavra,\n        context: palavra,\n        type: 'palavra',\n        page: page\n    };\n\n    const dominiosNodes = data.map(it => ({\n        id: `d_${it}`,\n        label: it,\n        context: palavra,\n        type: 'dominio'\n    }));\n\n    const newNodes = dominiosNodes\n        .filter(isNotInCollection(currentNodes));\n\n    const newEdges = newNodes\n        .map(it => ({\n            source: palavraNode.id,\n            target: it.id,\n            palavra: palavraNode.label,\n            dominio: it.label,\n        }));\n\n    newNodes.push(palavraNode);\n\n    const newCluster = [].concat(palavraNode.id, newEdges.map(it => it.target));\n    let newClusterAdded = false;\n    const newClusters = [];\n\n    for (const currentCluster of currentClusters) {\n        // cluster que não tem a palavra: mantém na lista de clusters\n        const isOnCurrentCluster = currentCluster.indexOf(palavraNode.id) !== -1;\n        if (!isOnCurrentCluster) {\n            newClusters.push(currentCluster);\n        }\n\n        // remove palavra do cluster atual e coloca em um novo\n        if (isOnCurrentCluster && page === 1) {\n            newClusters.push(newCluster);\n            newClusterAdded = true;\n            newClusters.push(currentCluster.filter(it => it !== palavraNode.id))\n        }\n\n        // adiciona ao cluster que ja tem a palavra\n        if (isOnCurrentCluster && page >= 2) {\n            newClusters.push([...currentCluster, ...newCluster]);\n            newClusterAdded = true;\n        }\n    }\n\n    !newClusterAdded && newClusters.push(newCluster);\n\n    return {\n        palavraBusca: \"\",\n        currentNode: palavra,\n        elements: {\n            nodes: merge(newNodes, currentNodes),\n            edges: newEdges.concat(currentEdges),\n            clusters: newClusters\n        }\n    }\n};\n\nconst receiveRelacionadas = (previousState, action) => {\n    const {dominio, palavra, page, data} = action;\n\n    if (data.length === 0) {\n        return previousState;\n    }\n\n    const currentElements = previousState.elements;\n\n    const currentNodes = currentElements.nodes;\n    const currentEdges = currentElements.edges;\n    const currentClusters = currentElements.clusters;\n\n    const dominioNode = {\n        id: `d_${dominio}`,\n        label: dominio,\n        context: dominio,\n        type: 'dominio',\n        page: page\n    };\n\n    const palavrasNodes = data\n        .concat(palavra)\n        .map(it => ({\n            id: `p_${it}`,\n            label: it,\n            context: dominio,\n            type: 'palavra'\n        }));\n\n    // FIXME trecho praticamente idêntico a receiveDominios: encapuslar\n    const newNodes = palavrasNodes\n        .filter(isNotInCollection(currentNodes));\n\n    const newEdges = newNodes\n        .map(it => ({\n            source: dominioNode.id,\n            target: it.id,\n            palavra: it.label,\n            dominio: dominioNode.label,\n        }));\n\n    newNodes.push(dominioNode);\n\n    const newCluster = [].concat(dominioNode.id, newEdges.map(it => it.target));\n    let newClusterAdded = false;\n    const newClusters = [];\n\n    for (const currentCluster of currentClusters) {\n        // cluster que não tem a palavra: mantém na lista de clusters\n        const isOnCurrentCluster = currentCluster.indexOf(dominioNode.id) !== -1;\n        if (!isOnCurrentCluster) {\n            newClusters.push(currentCluster);\n        }\n\n        // remove palavra do cluster atual e coloca em um novo\n        if (isOnCurrentCluster && page === 1) {\n            newClusters.push(newCluster);\n            newClusterAdded = true;\n            newClusters.push(currentCluster.filter(it => it !== dominioNode.id))\n        }\n\n        // adiciona ao cluster que ja tem a palavra\n        if (isOnCurrentCluster && page >= 2) {\n            newClusters.push([...currentCluster, ...newCluster]);\n            newClusterAdded = true;\n        }\n    }\n\n    !newClusterAdded && newClusters.push(newCluster);\n\n    return {\n        currentNode: dominio,\n        elements: {\n            nodes: merge(newNodes, currentNodes),\n            edges: newEdges.concat(currentEdges),\n            clusters: newClusters\n        }\n    };\n};\n\nconst receiveSignificados = (previousState, action) => {\n    const {palavra, dominio, data} = action;\n\n    console.log(data, \"receiveSignificados\");\n\n    return {\n        significado: {\n            palavra,\n            dominio,\n            definicoes: data\n        }\n    }\n\n};\n\nexport default {\n    receiveDominios,\n    receiveRelacionadas,\n    receiveSignificados\n};","import React, {Component} from \"react\";\n\nclass Significados extends Component {\n\n    constructor(props) {\n        super(props);\n        this.ref = React.createRef();\n    }\n\n    componentDidMount() {\n        // Evita que o click na própria janela de Significados o feche.\n        // Queremos somente que clicks fora dele façam isso.\n        this.ref.current.addEventListener('click', e => e.stopPropagation());\n    }\n\n    render() {\n        const {palavra, dominio, definicoes} = this.props;\n\n        return (\n            <div className=\"Significados\" ref={this.ref}>\n                <div className=\"title\">Significados</div>\n                <div className=\"subtitle\">\n                    <span className=\"highlight\">{palavra}</span> dentro do domínio conceitual <span className=\"highlight\">{dominio}</span>\n                </div>\n\n                {definicoes.map((it, i) =>\n                    <div className=\"definicao\" key={i}>\n                        <span className=\"index\">{i + 1}.</span>\n\n                        {it.dominios.length > 0 &&\n                        <span className=\"dominios\">{it.dominios.join(\", \")}</span>}\n\n                        <span className=\"texto\">{it.texto}</span>\n\n                        {it.score > 0 &&\n                        <span className=\"score\">{it.score}</span>}\n                    </div>\n                )}\n            </div>\n        )\n    }\n}\n\nexport default Significados;","import React, {Component} from 'react';\nimport cise from 'cytoscape-cise';\nimport cytoscape from 'cytoscape';\n\n// registra layout\ncytoscape.use(cise);\n\n/**\n * O cytoscape não foi implementado sob a filosofia declarativa.\n * Sua abordagem imperativa gera algumas dificuldades quando integramos com o React.\n * Esta classe é um wrapper para esconder essa integração meio \"deselegante\".\n *\n * Até tentei usar um wrapper já pronto, https://github.com/plotly/react-cytoscapejs,\n * mas tinha muitos bugs e não quis perder tempo.\n */\nclass WordGraph extends Component {\n\n    constructor(props) {\n        super(props);\n        this.graph = React.createRef();\n    }\n\n    componentDidMount() {\n        const {onClickNode, onClickEdge} = this.props;\n\n        this.cy = cytoscape({\n            container: this.graph.current,\n            elements: [],\n            style: [\n                {\n                    selector: 'node',\n                    style: {\n                        'background-color': ele => ele.data('type') === 'dominio' ? '#CCC' : 'green',\n                        'label': 'data(label)'\n                    }\n                },\n\n                {\n                    selector: 'edge',\n                    style: {\n                        'width': 3,\n                        'line-color': '#ccc'\n                    }\n                }\n            ]\n        });\n\n        this.cy.on('tap', 'node', function () {\n            onClickNode(this);\n        });\n\n        this.cy.on('tap', 'edge', function (e) {\n            console.log(e.renderedPosition);\n            onClickEdge(this);\n        });\n    }\n\n    draw(context, elements) {\n        if (!this.cy) return;\n\n        const formattedElements = toCytoscapeFormat(elements);\n\n        console.log(formattedElements.nodes, \"nodes\");\n        console.log(formattedElements.clusters, \"clusters\");\n\n        // removemos nós anteriores, pois podemos ter alterado alguma meta informação deles e queremos sobrescrever\n        this.cy.remove('node');\n        this.cy.add(formattedElements);\n\n        this.cy.layout({\n            name: 'cise',\n            // animate: 'end', // não funcionou bem com o cy.fit() do ready\n            fit: false,\n            nodeRepulsion: 5,\n            clusters: formattedElements.clusters, // clusters são os grupos do cise layout: os círculos\n            ready: () => {\n                // faz o viewport exibir os nodes do contexto atual, i.e, a íltima palavra escolhida\n                this.cy.fit(this.cy.$(`[context='${context}']`));\n            }\n        }).run();\n    }\n\n\n    shouldComponentUpdate(nextProps, nextState, nextContext) {\n        return this.props.elements !== nextProps.elements;\n    }\n\n    render() {\n        const {context, elements} = this.props;\n\n        // FIXME usar um callback adequado\n        this.draw(context, elements);\n\n        return (\n            <div className=\"WordGraph\" ref={this.graph}/>\n        );\n    }\n}\n\nconst toCytoscapeFormat = ({nodes, edges, clusters}) => ({\n    nodes: nodes.map(it => ({data: it})),\n    edges: edges.map(it => ({data: it})),\n    clusters,\n});\n\n\nexport default WordGraph;","import React, {Component} from 'react';\nimport {api, reducer} from '../api';\nimport Significados from \"./Significados\";\nimport WordGraph from \"./WordGraph\";\n\nimport './App.css';\n\nclass App extends Component {\n    state = {\n        palavraBusca: \"\",\n        currentNode: null,\n        significado: {\n            palavra: \"\",\n            dominio: \"\",\n            definicoes: []\n        },\n        elements: {\n            nodes: [],\n            edges: [],\n            clusters: [], // para o cise layout\n        },\n    };\n\n    componentDidMount() {\n        // Fecha janela de significados\n        document.addEventListener(\"click\", () => this.clearSignificado())\n    }\n\n    onChangeBusca = e => {\n        this.setState({palavraBusca: e.target.value})\n    };\n\n    onSearch = e => {\n        e.stopPropagation();\n        e.preventDefault();\n\n        const {palavraBusca} = this.state;\n\n        this.fetchDominios(palavraBusca, 1);\n    };\n\n    onClickNode = node => {\n        const currentPage = node.data(\"page\") || 0;\n        const nextPage = currentPage + 1;\n\n        const isPalavra = node.data('type') === 'palavra';\n        isPalavra ? this.onClickPalavra(node, nextPage) : this.onClickDominio(node, nextPage)\n    };\n\n    onClickPalavra = (node, page) => {\n        const palavra = node.data(\"label\");\n        this.fetchDominios(palavra, page);\n    };\n\n    onClickDominio = (node, page) => {\n        const dominio = node.data(\"label\");\n        const palavra = node.data(\"context\");\n        this.fetchRelacionadas(dominio, palavra, page);\n    };\n\n    onClickEdge = edge => {\n        const dominio = edge.data(\"dominio\");\n        const palavra = edge.data(\"palavra\");\n        this.fetchSignificados(dominio, palavra);\n    };\n\n    fetchDominios = (palavra, page) => {\n        api\n            .dominios(palavra, page)\n            .then(({data}) => reducer.receiveDominios(this.state, {\n                palavra,\n                page,\n                data,\n            }))\n            .then(newState => this.setState(newState));\n    };\n\n    fetchRelacionadas = (dominio, palavra, page) => {\n        api\n            .relacionadas(dominio, palavra, page)\n            .then(({data}) => reducer.receiveRelacionadas(this.state, {\n                palavra,\n                dominio,\n                page,\n                data,\n            }))\n            .then(newState => this.setState(newState));\n    };\n\n    fetchSignificados = (dominio, palavra) => {\n        api\n            .significados(dominio, palavra)\n            .then(({data}) => reducer.receiveSignificados(this.state, {\n                palavra,\n                dominio,\n                data,\n            }))\n            .then(newState => this.setState(newState));\n    };\n\n    clearSignificado = () => this.setState({significado: {}});\n\n    render() {\n        const {palavraBusca, currentNode, elements, significado} = this.state;\n\n        return (\n            <div className=\"App\">\n                <Header buscaValue={palavraBusca}\n                        onChangeBusca={this.onChangeBusca}\n                        onSearch={this.onSearch}/>\n\n                <div className=\"content\">\n                    {significado.palavra &&\n                    <Significados palavra={significado.palavra}\n                                  dominio={significado.dominio}\n                                  definicoes={significado.definicoes}/>}\n\n                    <Subtitle />\n\n                    <WordGraph context={currentNode}\n                               elements={elements}\n                               onClickNode={this.onClickNode}\n                               onClickEdge={this.onClickEdge}/>\n                </div>\n            </div>\n        );\n    }\n}\n\nconst Header = ({buscaValue, onChangeBusca, onSearch}) => {\n    return (\n        <div className=\"Header\">\n            <span className=\"title\">Lácio</span>\n\n            <form onSubmit={onSearch}>\n                <input type=\"text\"\n                       value={buscaValue}\n                       placeholder=\"Por ex: gato, terra, bóson\"\n                       autoFocus\n                       onChange={onChangeBusca}\n                />\n                <input type=\"submit\"\n                       value=\"Adicionar\"/>\n            </form>\n        </div>\n    )\n};\n\nconst Subtitle = () => {\n    return (\n        <div className=\"Subtitle\">\n            <div className=\"palavra\">palavra</div>\n            <div className=\"dominio\">domínio conceitual</div>\n        </div>\n    )\n};\n\nexport default App;\n","import App from './App';\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}